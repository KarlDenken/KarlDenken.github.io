<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2020/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划（Dynamic Programming），是一种常见的计算机算法，而且非常普遍的应用在我们身边各个角落。今天，我们从源头讲讲动态规划。</p><h2 id="一个钱包引发的问题"><a href="#一个钱包引发的问题" class="headerlink" title="一个钱包引发的问题"></a>一个钱包引发的问题</h2><p>在电子支付大行其道之前，人们在购物时常常会遇到一个问题，那就是 <strong>凑钱</strong>。假设你是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票，那么现在需要 <strong>用尽可能少的钞票凑出w金额</strong></p><p>依据生活经验，我们显然可以得到采取这样的策略：能用100的就尽量用100的，否则尽量用50的… 以此类推。在这种策略下，666=6<em>100+1\</em>10+1*10+1*5+1*1，总共用了10张钞票。我们把这种策略称呼为 <strong>贪心</strong>。贪心策略会使得w尽快变得很小。长期的生活实践告诉我们，贪心策略是正确的。</p><p>但是，如果我们换一个情况，贪心可能就不成立的。假如一个国家的钞票面值分别是1、5、11，那么我们在凑出15的时候，贪心策略就会出错：</p><ul><li>15 = 1*11 + 5*1 （用了5张钞票)</li><li>15 = 3*5 （用了3张钞票）</li></ul><p>为什么会这样呢？贪心策略错在了哪里？　</p><p><strong>鼠目寸光。</strong></p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。　　</p><p>在这里我们发现，<strong>贪心是一种只考虑眼前情况的策略</strong>。那么，现在我们怎样才能避免鼠目寸光呢？　　</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。　　</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：<em>“给定w，凑出w所用的最少钞票是多少张？”</em></p><p>接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？　　</p><p>明显 $cost = f(4) + 1 = 4 + 1 = 5 $ ，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。　　</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是 $cost = f(10) + 1 = 2 + 1 = 3$。　　</p><p>那么，现在w=15的时候，我们该取那种钞票呢？当然是各种方案中，cost值最低的那一个！　　</p><ul><li><p>取11：$cost = f(4) + 1 = 4 + 1 = 5$　</p></li><li><p>取5： $cost = f(10) + 1 = 2 + 1 = 3$ 　　</p></li><li><p>取1： $cost = f(14) + 1 = 4 + 1 = 5$</p></li></ul><p>显而易见，cost值最低的是取5的方案。我们通过上面三个式子，做出了正确的决策！　　</p><p>这给了我们一个 <strong>至关重要的启示</strong> :</p><p><strong>f(n) 只与 f(n-1), f(n-5), f(n-11) 有关</strong></p><p>更确切地说：　　</p><p>$$f(n) = min{f(n-1), f(n-5), f(n-11)} + 1 $$</p><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><pre><code class="python">f = [0]for i in range(1, n):  price_1 = f[i - 1] + 1  price_2 = f[i - 5] + 1 if i &gt;= 5 else 100  price_3 = f[i - 11] + 1 if i &gt;= 11 else 100  cost = min(price_1, price_2, price_3)  f.append(cost)return f[n-1]</code></pre><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：　　</p><ul><li>f(n)只与f(n-1), f(n-5), f(n-11)的值相关。　　</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。　　</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！　　</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。其他信息并不需要。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).　　</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。　　这</p><p>就是DP（动态规划，dynamic programming）.　　</p><p>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</p><h2 id="几个简单的概念"><a href="#几个简单的概念" class="headerlink" title="几个简单的概念"></a>几个简单的概念</h2><h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。　　</p><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。　　</p><p><strong>“未来与过去无关”，这就是无后效性。</strong></p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n)。f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。　　</p><p><strong>大问题的最优解可以由小问题的最优解推出，这个性质叫做“最优子结构性质”。</strong></p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？　　</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="DP的典型应用：DAG最短路"><a href="#DP的典型应用：DAG最短路" class="headerlink" title="DP的典型应用：DAG最短路"></a>DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><p><img src="https://pic1.zhimg.com/50/v2-38e9a487997d2eea979097fbc9e9e674_hd.jpg" srcset="/img/loading.gif" alt="一张地图。边上的数字表示过路费。"></p><center>一张地图。边上的数字表示过路费。</center>　　<p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).　　</p><p>想要到T，要么经过C，要么经过D。从而$f(T) = min{f(C) + 20, f(D) + 10}$.　　</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：　　</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。　　</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是$S-&gt;P-&gt;Q-&gt;T$  ，那肯定S走到Q的最优路径是$S-&gt;P-&gt;Q$ 。对一条最优的路径而言，从S走到沿途上所有的点（子问题）的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。　　</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><p>$$f(P) = min{f(R) + w_{R-&gt;P}}$$　　</p><p>其中R为有路通到P的所有的点， $w_{R-&gt;P}$为R到P的过路费。　　</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对DP原理的一点讨论"><a href="#对DP原理的一点讨论" class="headerlink" title="对DP原理的一点讨论"></a>对DP原理的一点讨论</h2><h3 id="DP的核心思想"><a href="#DP的核心思想" class="headerlink" title="DP的核心思想"></a>DP的核心思想</h3><p>DP为什么会快？　　</p><p>无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解。　　</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。　　</p><p>DP是枚举有希望成为答案的解。这个空间比暴力的小得多。　　也就是说：<strong>DP自带剪枝</strong>。DP舍弃了一大堆不可能成为最优解的答案。譬如：15 = 5+5+5 被考虑了。15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。　　<br>从而我们可以得到DP的核心思想：<strong>尽量缩小可能解空间</strong>。　　<br>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。　　</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><h3 id="DP的操作过程"><a href="#DP的操作过程" class="headerlink" title="DP的操作过程"></a>DP的操作过程</h3><p>一言以蔽之：大事化小，小事化了。　　</p><p>将一个大问题转化成几个小问题；　　</p><ul><li>求解小问题；　　</li><li>推出大问题的解。</li></ul><h3 id="如何设计DP算法"><a href="#如何设计DP算法" class="headerlink" title="如何设计DP算法"></a>如何设计DP算法</h3><p>下面介绍比较通用的设计DP算法的步骤。　　</p><p>首先，把我们面对的局面表示为x。这一步称为 <strong>设计状态</strong>。　　<br>对于状态x，记我们要求出的答案(e.g. 最小费用)为f(x).我们的目标是求出f(T).找出f(x)与哪些局面有关（记为p），写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><h3 id="DP三连"><a href="#DP三连" class="headerlink" title="DP三连"></a>DP三连</h3><p>设计DP算法，往往可以遵循DP三连：　　</p><ul><li>我是谁？  ——设计状态，表示局面　　</li><li>我从哪里来？　　</li><li>我要到哪里去？  ——设计转移　　</li></ul><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，更新能从x走到的一些解。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><h2 id="例题：最长上升子序列"><a href="#例题：最长上升子序列" class="headerlink" title="例题：最长上升子序列　　"></a>例题：最长上升子序列　　</h2><p>扯了这么多形而上的内容，还是做一道例题吧。　　</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。　　</p><p>e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。　　</p><h3 id="如何设计状态（我是谁）？"><a href="#如何设计状态（我是谁）？" class="headerlink" title="如何设计状态（我是谁）？　　"></a>如何设计状态（我是谁）？　　</h3><p>我们记 $f(x)$  为以$a_x$  结尾的LIS长度，那么答案就是$f(x)$。</p><ul><li>状态x从哪里推过来（我从哪里来）？　　</li></ul><p>考虑比x小的每一个p：如果$a_x &gt; a_p$，那么f(x)可以取f(p)+1.　　</p><blockquote><p>解释：我们把$a_x$接在$a_p$的后面，肯定能构造一个以$a_x$结尾的上升子序列，长度比以$a_p$结尾的LIS大1.那么，我们可以写出状态转移方程了：<br>$$f(x) = max_{p&lt;x, a_p &lt; a_x} {f(p)} + 1$$</p></blockquote><p>至此解决问题。两层for循环，复杂度O(n^2)</p><pre><code class="python">f = [0] * len(a)for x in range(1, n+1):  for p in range(1, x):    if a[p] &lt; a[x]:      f[x] = max(f[x], f[p] + 1)return max(f)</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的反思</title>
    <link href="/2020/05/31/%E6%88%91%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <url>/2020/05/31/%E6%88%91%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h1><p>又是一次组会。每两周举行一次的组会不知什么时候变成了我的噩梦。甚至我的身体已经出现了应激性反应：我的心跳会不由自主的加快，我的瞳孔会放大，我会下意识的远离手机，什么应用我都不想打开。我知道，我不是原来的自己了。</p><h2 id="我到底怎么了"><a href="#我到底怎么了" class="headerlink" title="我到底怎么了"></a>我到底怎么了</h2><p>每次碰到这样的时候，我就会问我自己一句话：我到底怎么了。回顾过去，我一直是大家嘴里的所谓好学生。是大家的榜样。以至于到现在我和我的好朋友微信的时候，他们鼓励的话语还是：“那不是你吗！”。可是我现在开始迷茫了。我究竟是谁？我又何德何能做到大家的榜样。</p><p>特别是读了研究生以后，这样的困惑一直萦绕在我的心头。我的颓势开始出现。我无法理解老师们说的内容，我无法理解我的师兄们在组会上提到的东西，我以前自视清高的一切都在被一点一点打碎，却无法被重现拼凑起来。</p><p>于是我开始自甘堕落，每条将自己的负面情绪发泄在信息流里。无论是微博还是视频网站，我会不由自主的不断刷新，企图得到新的内容。我就想一头饥饿的狼，渴望从里面得到一点慰藉。可是不得不承认，这些信息流的内容质量太低，我从里面得到的不是高质量的内容，但我的时间却被挥霍在这些无底洞里，最后一步一步滑向深渊。</p><h2 id="我要怎么做"><a href="#我要怎么做" class="headerlink" title="我要怎么做"></a>我要怎么做</h2><p>目前的我是彻底的一团烂泥，从内带外没有自信，没有笑容，没有目标，没有动力。我很不情愿，但也很无奈的承认：我必须从内到外彻底重新改造自己，不然我会在这样的深渊越滑越远，最终无法挽回。</p><p>第一要改的是心魔。我必须说，现在我不能追求论文的质量，而是必须很快的写出一篇文章，可以是一篇质量很烂的文章，就像以前被我鄙视的那些低质量的论文，灌水的论文，我比那些灌水的更差劲。这是个残酷的事实，我必须放下一切所谓名校的架子。那些都已经过去了，不负存在了，那些只是你的过去的一部分，仅此而已。</p><p>第二就是抛掉杂念。这里所说的杂念指的是一切与你的目的无关的东西，包括社会上发生的新闻，娱乐的新闻。那些和你没有关系。在主要任务之前，这些东西都是辅助的，他们不能帮忙获得论文的开题方向，他们也不能帮忙获得新的论文结构。只有老老实实的看，记录，实验才能得到游泳的结果。</p><p>第三就是形成系统的方法观。不能东一榔头，西一榔头。这样只会在不同的方向上浪费大量的时间和精力。人并不能多线程的工作，在同一个时间段里，只能做一个事情。特别是在你不熟悉的领域，到处乱窜不是一个高效的方法。需要有一张地图，才能最集中的利用身边的资源。</p><p>第四就是注意反馈。反馈是提升效率和确定方向的重要的因素。这里的反馈可以分为两种：自我可以评估的反馈和自我无法评估的反馈。自我可以评估的反馈包含刷题、考试、写教程等。而自我无法评估的反馈则包含研究方向，研究价值等。自我无法完成的评估需要与导师、同学多多交流。在之前，我都没有将自我无法完成的评估放在心上，导致可以用到的校友资源、教师资源完全没有用上。</p><h2 id="我下一步要怎么做"><a href="#我下一步要怎么做" class="headerlink" title="我下一步要怎么做"></a>我下一步要怎么做</h2><p>我现在需要的就是一个”地图“，可以告诉我我到底应该往哪个方向走。其次，我需要制定一个目标，以及从我现在的位置到目标的路程。</p><ul><li>地图：思维导图</li><li>目标：xx会议</li><li>路程：todo list</li></ul><p>当然，在这些事情之外，还有就是要解决掉我的拖延症。必须尽快达到心流的状态。这就要求我对于所有事情都快速反应，所以纸和笔是非常重要的工具。其次就是不断的交流和沟通，以及对偏离的方向不断修正。</p>]]></content>
    
    
    <categories>
      
      <category>自我</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hash 文件在macOS上的验证</title>
    <link href="/2020/05/30/hashfile/"/>
    <url>/2020/05/30/hashfile/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash-文件"><a href="#Hash-文件" class="headerlink" title="Hash 文件"></a>Hash 文件</h1><p>当我们从网络上下载得到一个文件，尤其是一个大文件时，，你会不会常常发现这一个一个问题：<strong>文件打不开</strong>！你会不会疑惑，明明从网上下载的文件好好的，怎么会出现文件错误，打不开呢？</p><h2 id="文件的完整性"><a href="#文件的完整性" class="headerlink" title="文件的完整性"></a>文件的完整性</h2><p>我们提到文件，尤其是大文件的下载的时候，我们常常会提到 <strong>P2P</strong> 或者是 <strong>磁力链</strong>。</p><ul><li><strong>P2P</strong>：P2P，也就是Peer-to-Peer的简称。以这种协议传输，每个电脑都会提供一份力量。文件被分成很多个小块，每台电脑都会提供一部分小块的上传和下载。</li></ul><p><img src="/2020/05/30/hashfile/OIP.MoRYiSMe1GqCA9tLYZ3kYAHaFj.jpeg" srcset="/img/loading.gif" alt="P2P network"></p><ul><li><strong>磁力链</strong>：磁力链和P2P类似，但是P2P需要一个中心服务器来告诉各个电脑有谁有文件，而磁力链则会自动找最近的有文件的服务器。</li></ul><p>这两种方式都有一个问题，那就是文件被分割成小块在互联网上传输。如果其中一块出了问题，那整个文件都不可是使用了。所以我们需要一个方法来验证文件的完整度。</p><blockquote><p>目前主流下载软件是已经包含了验证文件完整度的流程的，不需要再次验证</p></blockquote><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>hash本质上就是一个函数，他的输入是一串二进制，输出为一串字符。我们就称呼这串字符为 <strong>文件哈希(file hash)</strong> 或者 <strong>验证符(checksums)</strong>。一个理想的hash函数应该满足独一性，即每个独特的文件只能产生一个文件哈希，以至于任何一个微小的改变都会改变文件哈希的值。</p><p>目前有很多的hash算法，包括<code>SHA-256</code>，<code>SHA3</code>，<code>SHA1</code>，<code>MD5</code>和<code>CRC32</code>。但是目前这些算法都不是绝对安全的（也就是说，有可能两个文件会产生同样的哈希），不过在日常生活中他们已经常用来验证文件的完整性。</p><p>这里不对各个Hash算法的原理进行深入研究，如果有需求可以看看<a href="https://zhuanlan.zhihu.com/p/37165658" target="_blank" rel="noopener">知乎专栏</a>进行了解。</p><h2 id="在mac上验证文件Hash"><a href="#在mac上验证文件Hash" class="headerlink" title="在mac上验证文件Hash"></a>在mac上验证文件Hash</h2><p>mac目前提供命令行指令来看文件的hash值：</p><ul><li><p>显示SHA256哈希：<code>shasum -a 256 [filenames]</code></p></li><li><p>显示SHA1哈希：<code>shasum -a 1 [filenames]</code></p></li><li><p>显示MD5哈希：<code>md5 -r [filenames]</code></p></li><li><p>显示CRC32哈希：<code>crc32 [filenames]</code></p></li></ul><p>有时候我们下载时会提供包含hash的验证文件。我们称呼这些文件为验证文件（checksums files）。一个验证文件（checksums file）一般包含多行hash-文件名对。你可以用一行指令轻松的验证所包含的所有文件。当有多个文件时，这个指令很管用。</p><blockquote><p>注意：验证文件必须与内部提到的文件在同一个文件夹</p></blockquote><ul><li><p>验证SHA256文件（通常文件名是 SHA256SUMS）：<code>shasum -a 256 -c [SHA256SUMS]</code></p></li><li><p>验证SHA1文件（通常文件名是 SHA1SUMS）：<code>shasum -a 1 -c [SHA1SUMS]</code></p></li></ul><p>mac不提供原生的MD5验证指令，但可以从<code>Homebrew</code>轻松下载：</p><p><code>brew install md5sha1sum</code></p><ul><li>验证MD5文件（通常文件名是 MD5SUMS）：<code>md5sum -c [MD5SUMS]</code></li></ul><h2 id="创建验证文件"><a href="#创建验证文件" class="headerlink" title="创建验证文件"></a>创建验证文件</h2><p>我们也可以生成自己的验证文件，可以用于日后的验证或者拷贝大型文件的完整性验证</p><p><code>shasum -a 256 [files] &gt; [SHA256SUMS]</code></p><blockquote><p>注意：SHA256对大型文件的处理速度比较慢，需要耐心等待</p></blockquote><p><img src="/2020/05/30/hashfile/%E6%88%AA%E5%B1%8F2020-05-30%2015.16.00.png" srcset="/img/loading.gif" alt="截屏2020-05-30 15.16.00"></p><h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><p>在一些文件下载网站，如<a href="https://msdn.itellyou.cn" target="_blank" rel="noopener">MSDN</a>，里面的软件是会提供下载后验证SHA1的，我们可以下载之后验证文件的完整性。</p><p><img src="/hashfile/%E6%88%AA%E5%B1%8F2020-05-30%2015.21.56.png" srcset="/img/loading.gif" alt="截屏2020-05-30 15.21.56"></p><p>同时，有时候路边购买的U盘，也可能出现信息丢失的情况，我们也可以用这种方式验证文件完整性。</p><p>另外，对于大型的文档，我们在确定终稿的时候生成SHA文件，可以避免对文件的修改过于细微而无法确认文件的完备性。当然，最好还是用Git进行版本管理。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2020/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>背包问题泛指一下这一种问题：</p><blockquote><p>给定一组有价值和固定重量的物品，以及一个已知最大承重的背包，求在不超过背包最大承重量的前提下，能放进把背包里的物品的最大总价值。</p></blockquote><p>这是一种典型的使用 <strong>动态规划</strong> 解决的问题，我们可以具体分成三个问题：</p><ul><li>0-1 背包问题</li><li>完全背包问题</li><li>多重背包问题</li></ul><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0 - 1背包"></a>0 - 1背包</h2><blockquote><p>0 - 1 背包指每一种物品只有一件，可以选择放或者不放。假设有<code>n</code>件物品，背包承重为<code>C</code></p></blockquote><p>对于这种问题，我们用一个二维数组 <code>f[i][c]</code>，其中<code>i</code>表示放入背包的是前i件物品，<code>c</code>表示背包的承重，<code>f[i][c]</code>表示当前状态放进背包里的物品最大价值，那么最终结果就是<code>f[n][C]</code></p><p>动态规划有三个基本要素：<strong>最优子结构</strong>，<strong>边界条件</strong> 和 <strong>状态转移方程</strong>：</p><ul><li><strong>状态转移方程</strong>：对于第 <code>i</code>个物体，有两种可能，拿 或者 不拿。拿的话，则<code>f[i][c] = f[i-1][c - w[i]] + v[i]</code>，即在前<code>i-1</code>个物体，花销为<code>c-w[i]</code>的情况下，拿了第<code>i</code>个物体，同时花销多花了<code>w[i]</code>，收益增加了<code>v[i]</code>。不拿的话，则<code>f[i][c] = f[i-1][c]</code>，即在前<code>i-1</code>个物体，花销为<code>c</code>的情况下，不花<code>w[i]</code>，同时也没有收益。所以我们的状态转移方程为：</li></ul><pre><code class="python">f[i][c] = f[i-1][c-w[i]] + v[i] if add ith itemf[i][c] = f[i-1][c] if not add ith item</code></pre><ul><li><strong>最优子结构</strong>：我们的目的是为了获得最大的价值，所以最优子结构为：</li></ul><pre><code class="python">f[i][c] = max(f[i-1][c], f[i-1][c-w[i]] + v[i])</code></pre><ul><li><strong>边界条件</strong>：最开始我们的背包什么都没有，所以<code>f[0][0] = 0</code>，没有花销，同时也没有收益。当背包放满了，放不下了，我们也没法更新，所以 <code>f[i][c] = f[i-1][c] if c &lt; w[i]</code>，最后返回<code>f[n][C]</code></li></ul><p>有了上面的几个条件，我么就可以开始写代码了：</p><pre><code class="python">def knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  # w is the weight, v is the value, n is the number of item and m is the total cost affordable  f = [[0] * n for _ in range(C + 1)] # generate array  for j in range(1, C+1):    if j &gt;= w[0]:      f[0][j] = v[0] # when c &gt; w[0], we can at least put item 0 and get value v[0]      else:      f[0][j] = 0  for i in range(1, n):    for j in range(1, C+1):      if j &lt; w[i]:        f[i][j] = f[i-1][j]      else:        f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[[i]])  return f[n-1][C]</code></pre><p>我们用这样一个例子：总共有5个商品：a,b,c,d,e，重量为：2, 2, 6, 5, 4，价值为：6, 3, 5, 4, 6。背包可承载重量为10，我们可以得到下面的表格：</p><table><thead><tr><th></th><th>W</th><th>V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th align="center">备注</th></tr></thead><tbody><tr><td>a</td><td>2</td><td>6</td><td>0</td><td>0</td><td><strong>6</strong></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td align="center">consider item a</td></tr><tr><td>b</td><td>2</td><td>3</td><td>0</td><td>0</td><td>6</td><td>6</td><td><strong>9</strong></td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td><td align="center">consider item b</td></tr><tr><td>c</td><td>6</td><td>5</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>9</td><td>9</td><td><strong>11</strong></td><td>11</td><td>14</td><td align="center">consider item c</td></tr><tr><td>d</td><td>5</td><td>4</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>9</td><td>10</td><td>11</td><td>13</td><td>14</td><td align="center">consider item d</td></tr><tr><td>e</td><td>4</td><td>6</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td align="center">consider item e</td></tr></tbody></table><p>所以最后返回 <strong>15</strong>，也就是把a,b,e放到包里，总共重量8，总价值15</p><p>我们来计算时间复杂度和空间复杂度。两个循环嵌套，所以时间复杂度为O(nC)，空间复杂度开了一个[n][C]的数组，所以也是O(nC), 我们可以接着优化。我们发现，每一行数组都只跟上一级数组有关，所以空间复杂度可以简化为O(2C),我们还可以进一步优化为O(C)，那就是 <strong>从后往前填数组</strong>，因为对于i次更新，只会追溯到i-1次更新数据中c以前的数据，这样就只用保留一行数组。实质上也就是用上一轮的数据来更新这一轮。</p><pre><code class="python">def knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    for j in range(C, w[i]-1, -1):      f[j] = max(f[j], f[j - w[i]] + v[i])  return f[C]</code></pre><p>如果题目要求我们输出最优解，而不只是答案，我们需要保存么一次变化的值，用来回溯最优解。</p><p>如果固定背包必须装满，那么除了<code>f[0]</code>初始化为0，其他<code>f[1~c]</code>都要初始化为<code>float(&#39;-inf&#39;)</code>，可以理解为没要物体时，除了把背包容量为0，那么什么都不装刚好装满，如果背包容量大于0，则除了<code>f[0]</code>外我们那种情况都装不满，所以初始化为负无穷。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><blockquote><p>完全背包问题就是每一个物体有无数件，假设有<code>n</code>件物品，背包承重为<code>C</code></p></blockquote><p>相比于0-1背包，我们每一件物体选取没有数量限制，那么我们可以取0,1,2, … 到最多<code>C//w[i]</code>，按照0-1把背包的分析，我们可以写出状态转移方程：</p><pre><code class="python">f[i][j] = max(f[i-1][j], f[i-1][j - k * w[i]] + k * v[i]), where 0 &lt;= k*w[i] &lt;= j</code></pre><p>时间复杂度变为了$O(nC* \Sigma C // w[i])$，我们也有进行优化。</p><p>会想一下0-1背包中，第一层是从0到n-1，第二层从右到左。<strong>从右都左</strong> 是为了保证第i件物体一点从i-1件物体的撞状态而来，也就是说，考虑第i件物体时，依据的是一个一定没有选中过i-1件物体的结论。如果将第二层循环改成 <strong>从左到右</strong> 就变成选第i件物体时依然从拿过第i件物体的结论中递推。状态转移方程为：</p><pre><code class="python">f[i][j] = max(f[i-1][j], f[i][j - w[i]] + v[i])</code></pre><p>所以代码为：</p><pre><code class="python">def complete_knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(1, n):    for j in range(w[i], C + 1):      f[j] = max(f[j], f[j - w[i]] + v[i])  return f[C]</code></pre><p>这个写法和0-1背包几乎完全一致，不过第二层循环变成了从左到右更新。</p><h2 id="多重（有界）背包问题"><a href="#多重（有界）背包问题" class="headerlink" title="多重（有界）背包问题"></a>多重（有界）背包问题</h2><blockquote><p>如果限定物品i最多只能拿<code>m[i]</code>个，则问题称为有界或多重背包问题</p></blockquote><p>与完全背包相似，我们可以写出状态转移方程：</p><pre><code class="python">f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i])  where 0&lt;=k&lt;=m[i]</code></pre><p>此时时间复杂度为$O(C \Sigma m[i])$，一种简化的方法是将问题转化为物体数量为$\Sigma m[i]$的0-1背包问题，比如a有2个，每个价值为5，我们可以看作a1，a2两个物体，每个物体的价值是5。但时间复杂度还是$O(C \Sigma m[i])$。</p><p>我们尝试用二进制的思想来优化，将有m[i]个的第i件物体分成k+1组，每组一个系数，分别为$1, 2, 2^2, …, 2^{k-1}, m[i] - 2^k + 1$，k为保证最后一项大于0的最大整数，原本有m[i]件的第i件物体，被分成了log(m[i])件，每一件物体的价值和费用都乘以原来的系数倍，这样时间复杂度变成了$O(C \Sigma \log m[i])$</p><p>这样分组是为了保证0～m[i]中的每一个数都可以用新分组的系数组合而成，且不会超过m[i]，证明引用<a href="https://zhuanlan.zhihu.com/p/85780471" target="_blank" rel="noopener">知乎专栏</a></p><blockquote><p>首先看系数中除了最后一项的所有项，每一项都是2的次方，也就是说如果用二进制表示用它们组合可以得到$0$ ~ $2^k - 1$中的所有数，这样我们还剩下$2^k$~$m[i]$中的数需要表示，证明完成了一半；现在把最后一个系数加进来，我们发现它加上之前系数可以表示的最大值$2^k - 1$后得到的正是$m[i]$，我们可以想象先将所有系数全部取走，得到的便是$m[i]$，然后根据选择丢弃不需要的系数，我们便可以得到$m[i] - 2^k + 1$ ~ $m[i]$中的所有值（从$1$ ~ $2^k - 1$ 依次丢)，那么现在就剩下$0$ ~ $m[i] - 2^k$ 这些值需要表示，而现在只需要证明  $2^k - 1$ 比 $m[i] - 2^k$ 要大就行了，因为前面证明已经得到了 $0$ ~ $2^k - 1$ 之间的数，这个证明很简单，直接相减，然后利用 $m[i] - 2^k + 1 &gt; 0$的性质就可以得证。</p></blockquote><p>我们来写代码，我们要先抽象出0-1背包和完全背包，然后进一步定义<code>MultilePack</code></p><pre><code class="python">def zeroOnePack(f, wi, vi, C):  for j in range(C, wi - 1, -1):    f[j] = max(f[j], f[j - wi] + vi)def completePack(f, wi, vi, C):  for j in range(wi, C + 1):    f[j] = max(f[i], f[j - wi] + vi)def multiplePack(f, wi, vi, mi, C):  if mi * wi &gt;= C:    # can take all, like complete pack    completePack(f, wi, vi, C)    return  # the rest is 0 - 1 pack  k = 1  while k &lt; mi:    zeroOnePack(f, wi * k, vi * k, C)    mi -= k    k *= 2  # the rest  zeroOnePack(f, wi * mi, vi * mi, C)def multi_knapsack(v: List[int], w: List[int], m: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    multiplePack(f, w[i], v[i], m[i], C)  return f[C]</code></pre><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>如果物品中三种情况都有，那么我们可以分三种情况就行了</p><pre><code class="python">def hybrid_knapsack(v: List[int], w: List[int], m: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    if (m[i] == 1):      zeroOnePack(f, w[i], v[i], C)    elif m[i] == INT_MAX:      completePack(f, w[i], v[i], C)    else:      multiplePack(f, w[i], v[i], C)  return f[C]</code></pre><p>对于其他的，比如填满背包问题，找钱问题，我会在下一次的动态规划介绍中提出。</p>]]></content>
    
    
    <categories>
      
      <category>算法导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间管理</title>
    <link href="/2020/05/27/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <url>/2020/05/27/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><p>时间管理是一个人成长过程中非常重要的一个部分。学会好的时间管理对于学习效率的提升有着很大的作用。为了能够最大限度的提升自己的学习效率，我打算利用这个时间对于时间规划做出一个提升。</p><h2 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h2><p>在制定新的时间安排之前，我们需要分析原有的时间安排上的不足。下面是一张目前的时间使用图</p><p><img src="/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/IMG_7CFC16044738-1.jpeg" srcset="/img/loading.gif" alt="时间使用管理图"></p><p>我们可以发现，现在每天的设备使用时间已经超过了13个小时。相比以疫情之前，使用时间有了大幅的上升。达到了每天超过了12个小时。这就相当于 <strong>每天有超过一般的时间花费在了这些点子设备上</strong>。杜对于一个还在学习的学生来说，这样的时间分配明显是不合理的。 我们接下来详细分析到底时间花在了什么地方。</p><h3 id="时间类型分析"><a href="#时间类型分析" class="headerlink" title="时间类型分析"></a>时间类型分析</h3><p><img src="/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/IMG_AF0E4A1D5DA6-1.jpeg" srcset="/img/loading.gif" alt="时间管理分析图"></p><p>在横向时间轴上，我们可以发现，对于屏幕的依赖是从早上睁眼开始的。睁眼的那一个小时内，主要使用的是社交和其他。具体为 <strong>微博</strong> 和 <strong>知乎</strong>。而从这之后，几乎每个小时都有屏幕的使用时间，这个时间也就是微博和Bilibili和知乎。在中午的时候，有过一段短暂的休息，这是午饭和午休带来的。而下午的时候，对于屏幕的需求又出现了。这种情况一次持续到12点。</p><p><img src="/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/IMG_31EE70C8549C-1.jpeg" srcset="/img/loading.gif" alt="类别分析图"></p><p>我们对各种App进行分析，可以发现：一天时间内，使用时间最长的就是bilibili。时间达到了2小时以上。这是因为最近我关注很多的博主，所以可以观看的视频数也就大幅上升。其次就是手机淘宝，这个时长的提升源自于淘宝直播，接下来就是微博国际版，也就是微博。排名第四的是知乎，微信在之后只有11分钟的占有，也就可以忽略不计了。</p><h3 id="时间类型总结"><a href="#时间类型总结" class="headerlink" title="时间类型总结"></a>时间类型总结</h3><p>可以发现，吞噬我大量时间的主要是下列的应用：</p><ul><li>Bilibili</li><li>微博</li><li>知乎</li><li>淘宝</li></ul><p>于此同时，在我的每天日常了少了很多的：</p><ul><li>学习</li><li>运动</li><li>睡眠管理</li></ul><p>所以新的时间管理方案就是要从这些吞噬时间的App里面把时间夺回来，并分配到应该分配到的时间里。</p><h2 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h2><h3 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h3><p>为了保持身体的健康，我们首先需要确定一个大致的框架。这里我们参考了所谓最健康的时间安排<sup>1</sup>。我们可以得到一个大概的时间框架：</p><ul><li>起床时间：7:00</li><li>睡觉时间：22:30</li><li>工作时间：9：00 - 10:00（复杂性工作），14：00 - 16:00（日常工作）</li><li>午睡时间：13:00 - 14:00</li><li>午饭时间：12:00 - 12:30</li><li>锻炼时间：19:00</li><li>看书娱乐：20:00 - 22:00</li><li>热水澡：22:00 - 22:30</li></ul><p>按照上面的大框架，我们可以得到一个睡眠时间为8.5h。按照人体所需的睡眠时间来看，人体需要的睡眠时间为7-9个小时<sup>2</sup>。所以目前来看睡眠的时间是够的，同时，足够的睡眠可以保证皮肤的恢复，避免过早的产生细纹和皱纹，细化毛孔。这可比再多的医学美容方法靠谱的多。</p><h3 id="元素分配"><a href="#元素分配" class="headerlink" title="元素分配"></a>元素分配</h3><p>由于现在还是在疫情的自我在家隔离起，所以没有通勤的大量影响。但是，要考虑其他时间所占用的时间，这些元素包括：</p><ul><li>洗漱：15min</li><li>洗澡：20min</li><li>做饭：45min</li><li>吃饭：30min</li></ul><p>以上都是基本生活所需要的时间，我们像搭积木一样要把这些时间安排到空闲的时间内，所以我我们得到了一个基础的时间分配：</p><table><thead><tr><th align="center"><strong>项目</strong></th><th align="center"><strong>时间</strong></th></tr></thead><tbody><tr><td align="center">起床</td><td align="center">7:00</td></tr><tr><td align="center">洗漱</td><td align="center">7:05 - 7:20</td></tr><tr><td align="center">早餐</td><td align="center">7:30 - 8:00</td></tr><tr><td align="center">工作1</td><td align="center">8:30 - 11：30</td></tr><tr><td align="center">午餐</td><td align="center">12:00 - 12:30</td></tr><tr><td align="center">午休</td><td align="center">13:00 - 14:00</td></tr><tr><td align="center">工作2</td><td align="center">14:00 - 17:00</td></tr><tr><td align="center">锻炼</td><td align="center">17:30 - 18:30</td></tr><tr><td align="center">晚餐</td><td align="center">19:00 - 19: 30</td></tr><tr><td align="center">休息（额外学习)</td><td align="center">20:00 - 22:00</td></tr><tr><td align="center">洗漱</td><td align="center">22:00 - 22:30</td></tr><tr><td align="center">上床睡觉</td><td align="center">22:30</td></tr></tbody></table><h3 id="细致安排"><a href="#细致安排" class="headerlink" title="细致安排"></a>细致安排</h3><p>对于工作，我们使用 <strong>刻意学习（Delibrate Learning）</strong> 方法，主要元素为：1）刻意练习 2）注意反馈 3）利用反馈，修复之前的错误。同时，根据早上学习效果更好的结论，我们安排早上学习困难的东西。什么是困难的东西？那就是算法。算法非常困难，所以我们放在早上学习。</p><p>下午更多适合一些重复性的工作。什么工作适合重复性的劳动，对我来说就是读论文，了解目前科技圈，尤其是我目前所研究的领域，最新的进展是什么。</p><p>至于晚上，我们可以放一些自己感兴趣的其他领域，用来做平时学习的补充和放松，不至于太多时间都放在学习上。</p><hr><p>[1] <a href="https://zhuanlan.zhihu.com/p/32842773" target="_blank" rel="noopener">知乎：全球公认最健康的作息时间</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/80233166" target="_blank" rel="noopener">知乎：睡眠时间需要多久才够</a></p>]]></content>
    
    
    <categories>
      
      <category>自我</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer（0）</title>
    <link href="/2020/04/18/%E5%89%91%E6%8C%87offer_0/"/>
    <url>/2020/04/18/%E5%89%91%E6%8C%87offer_0/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer（0）-知识储备"><a href="#剑指offer（0）-知识储备" class="headerlink" title="剑指offer（0）- 知识储备"></a>剑指offer（0）- 知识储备</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coronavirus and pets - How COVID-19 affects cats and dogs</title>
    <link href="/2020/04/06/English%20Expression%20Regarding%20COVID-19/"/>
    <url>/2020/04/06/English%20Expression%20Regarding%20COVID-19/</url>
    
    <content type="html"><![CDATA[<h1 id="Coronavirus-and-pets-How-COVID-19-affects-cats-and-dogs"><a href="#Coronavirus-and-pets-How-COVID-19-affects-cats-and-dogs" class="headerlink" title="Coronavirus and pets: How COVID-19 affects cats and dogs"></a>Coronavirus and pets: How COVID-19 affects cats and dogs</h1><p>Coronaviruses have lived and thrived in animals for thousands of years, but only a handful have been known to cause illness in humans. The coronavirus at the center of the current pandemic, SARS-CoV-2, is incredibly successful at spreading from human to human. As of early April — just four months after it was first detected — the virus had infected over 1 million people and spread to over 180 counties.</p><p>It turns out that SARS-CoV-2 can hijack animal cells, too. Scientists believe the disease originated in Chinese horseshoe bats before it jumped into an intermediary animal and, form there, found its way into humans. The virus is able to inject itself into cells by binding to a cell surface protein known as ACE2, which is present in many species of animal.</p><p>Some media reports have shown that the coronavirus can infect our companion animals — and more exotic species like tigers and lions — but cases are rare. It appears that transmission of the disease from human to animal is low, and there’s no reason to think you might catch the disease from a feline friend who has been wandering the neighborhood. The World Health Organization states there is “no evidence that a dog, cat or any pet can transmit COVID-19”.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发要求中的那些名词是什么</title>
    <link href="/2020/04/06/%E5%BC%80%E5%8F%91%E8%A6%81%E6%B1%82%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%90%8D%E8%AF%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/04/06/%E5%BC%80%E5%8F%91%E8%A6%81%E6%B1%82%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%90%8D%E8%AF%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="开发面试要求中的那些名词"><a href="#开发面试要求中的那些名词" class="headerlink" title="开发面试要求中的那些名词"></a>开发面试要求中的那些名词</h1><p>又到了一年的面试季，虽然收到新冠肺炎的影响，本次面试很多都是在线上进行，但是面试的难度仍然不减。笔者在投稿时也正在投简历和准备面试的重要节点。然而，现在算法的岗位处于白热化的竞争状态，相信很多读者和笔者一样有转投开发的岗位。可是很多开发岗位的名词尚属第一次听到，所以，这一次我们来了解一些那些可能出现在开发面试要求中的那些名词。</p><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>在2002年10月，Rod Johnson 在其撰写的 <em>Expert One-on-One J2EE</em> 的书中，提出了一个基于普通Java类和依赖注入的简单组件框架。在书中，他编写了超过 30,000 行的基础结构代码。包含许多可重用的 Java 接口和类。在书发布后不久，开发者 Juergen Hoeller 和 Yann Caroff 说服 Rod Johnson 创建一个基于基础结构代码的开源项目。随后，Rod，Juergen 和 Yann 于 2003 年 2 月左右开始合作开发该项目。Yann 为新框架创造了“Spring”的名字。Spring 框架也就此应运而生。</p><p>Spring 框架用一句话来说，就是 <strong>一个特殊的开发应用框架</strong>，这个框架有着以下几个标签：<code>轻量级</code>，<code>非侵入式</code>，<code>一站式</code>，<code>模块化</code>等特点。在Spring框架内，主要设计到的名词如下：</p><ul><li><p><strong>应用程序</strong>：能完成我们所需要功能的成品，比如购物网站，OA系统，ERP系统等。</p></li><li><p><strong>框架</strong>：是能完成一定功能的半成品。如果我们要来构造一个购物网站，我们可以通过框架进行开发，框架可以提供数据的写入，读取等功能，而我们可以设计一些额外的功能来完成商品的入库、出库等。这些框架提供了基础功能，可以很好的简化开发的流程。</p></li><li><p><strong>非侵入式设计</strong>：在设计中，无需继承框架提供的类，这样的设计，就是非侵入式设计。如果继承了这些框架类，就是侵入式设计。侵入式设计，如果以后想更换框架，之前写的代码就必须重写，如果是非侵入式设计，之前写过的代码可以接着使用。</p></li><li><p><strong>轻量级/重量级</strong>：轻量级是相较于重量级而言的。轻量级一般是非侵入式的，所依赖的东西非常好，占用的资源也非常少，部署简单，容易使用。重量级反之。</p></li><li><p><strong>POJO（Plain Old Java Object）</strong>：简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p></li><li><p><strong>容器</strong>：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p></li><li><p><strong>IOC（Inversion of Control）</strong>：控制反转，又叫做依赖注入，就是由容器控制程序之间的关系，而非传统设计中，由代码直接控制。</p></li><li><p><strong>Bean</strong>：Spring IoC 容器管理对象。</p></li><li><p><strong>AOP</strong>： AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p></li></ul><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache，也就是 <strong>缓存</strong>，就是将程序或者系统经常要调用的对象存在内存中，使用的时候可以快速调用，不必再去创建新的重复的实例，从而减少系统开销，提高系统效率。</p><p>缓存主要可以分成两大类：</p><ul><li><p><strong>文件缓存</strong>：把数据存储在磁盘上。</p></li><li><p><strong>内存缓存</strong>：实现一个类中静态Map，对这个Map进行常规的增删查。</p></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC框架，全称Remote Procedure Call Protocal，也就是远程过程调用协议。也就是两台服务器A，B，一个应用部署在服务器A上，想调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>]]></content>
    
    
    <categories>
      
      <category>名词解释</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
      <tag>名词解释</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在远程使用Jupyter Notebook</title>
    <link href="/2020/04/04/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BD%BF%E7%94%A8jupternoteboook/"/>
    <url>/2020/04/04/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BD%BF%E7%94%A8jupternoteboook/</url>
    
    <content type="html"><![CDATA[<h1 id="如何在远程使用Jupter-Notebook"><a href="#如何在远程使用Jupter-Notebook" class="headerlink" title="如何在远程使用Jupter Notebook"></a>如何在远程使用Jupter Notebook</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于很多同学而言，做研究，尤其是做人工智能的研究，都需要一台很强大的电脑。但是现在可以跑起来的电脑往往耗资巨大。很多学校都是使用一台强大的服务器，然后给学生们提供一个账号，利用这个账号登陆进行处理。但是这就出现了一个问题。很多同学已经习惯了使用Jupyter Notebook来进行可视化处理，对于远程的Linux服务器，如何可以使用Jupter Notebook呢？这篇文章就简要的告诉你如何处理这样的问题。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="登陆服务器"><a href="#登陆服务器" class="headerlink" title="登陆服务器"></a>登陆服务器</h3><p>首先需要 <strong>登陆你的远程Linux服务器</strong></p><pre><code class="shell">ssh &lt;your_ip_address&gt; -p &lt;your_port&gt;</code></pre><p>并在内部建立一个<code>jup</code>文件夹，用来存放notebook文件</p><h3 id="安装Jupyter-Notebook"><a href="#安装Jupyter-Notebook" class="headerlink" title="安装Jupyter Notebook"></a>安装Jupyter Notebook</h3><p>如果是使用的anaconda或者是miniconda，jupyter notebook已经安装好了。如果没有，需要在服务器端安装jupyter notebook</p><pre><code class="shell">conda install jupyter Notebook</code></pre><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><p>安装好了Jupyter Notebook，就需要来生成配置文件。如果是第一次设置配置文件，需要先生成配置文件</p><pre><code class="shell">jupyter notebook --generate-config</code></pre><p>生成文件之后，需要设置密码。如果密码是123456，则应该操作为</p><pre><code class="shell">&gt;&gt;&gt; from notebook.auth import passwd&gt;&gt;&gt; passwd(&#39;123456&#39;)&#39;sha1:xxxxxxxxxxxxxxxxxxxxxxxx&#39;</code></pre><p>会返回一个sha1密码，然后用vim打开刚刚的配置文件（一般会在根目录/.jupyter/jupyter_notebook_config.py），在开头插入下列一些代码</p><pre><code class="python">c.NotebookApp.ip=&#39;0.0.0.0&#39; # 广播给所有人c.NotebookApp.password = u&#39;&lt;密码&gt;&#39; # &lt;密码&gt;就是之前的sha1:xxxxxxxxxxxxc.NotebookApp.open_browser = False # 不打开浏览器c.NotebookApp.port = 8050 # 使用8050作为跳转的接口</code></pre><h3 id="设置后台运行"><a href="#设置后台运行" class="headerlink" title="设置后台运行"></a>设置后台运行</h3><p>成功设置之后，我们更需要Jupyter Notebook在后台运行。这样我们无论什么时候运行，只需要打开网页，我们就可以使用Jupyter Notebook了。这样更加方便。我们需要的指令就是<code>nohup</code></p><pre><code class="shell">cd &lt;your_directory&gt;nohup jupyter notebook --no-browser --port 8050 --ip=&lt;your ip&gt; 2&gt;&amp;1 &amp;</code></pre><p>其中<code>nohup</code>的目的就是不挂断的运行程序。并且在最后我们使用<code>&amp;</code>来保证在后台运行。我们开始jupyter notebook，不用浏览器，端口好设置为8050，ip地址设置为地址，<code>2&gt;&amp;1</code>中，&amp;1表示文件描述符，也就是标准输出stdout，2则表示标准错误，也就是stderr。整个的意思就是将标准错误重定向到标准输出。由于nohup会自动生成一个nohup log记录活动。这样的指令可以使所有的错误和标准指令都保存在nohup内部</p><h3 id="使用Jupyter-Notebook"><a href="#使用Jupyter-Notebook" class="headerlink" title="使用Jupyter Notebook"></a>使用Jupyter Notebook</h3><p>现在，打开任意浏览器，输入地址<code>https://&lt;your ip&gt;:8050/</code>，然后开始愉快的使用jupyter notebook吧</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程</tag>
      
      <tag>Jupyter Notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020</title>
    <link href="/2020/04/02/2020/"/>
    <url>/2020/04/02/2020/</url>
    
    <content type="html"><![CDATA[<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><p>回首2019，有那么多想干的事情没有干。原先想着到了2020年了，可以再加一把劲把事情都干完。可是突如其来的疫情，却彻底打乱了我的节奏。写下这段文字的时候，2020年转眼间已经过去了1/4，可是我却度过了人生有史以来最舒服的几个月。没有考虑任何东西，没有学习到任何东西。回望我的同学们，都利用这段时间进行了大范围的联系，可是我却白白浪费了。</p><p>好在意识到这个问题还不算晚，现在开始我也要好好学习，天天向上了。</p>]]></content>
    
    
    <categories>
      
      <category>自我</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我反省</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/02/hello-world/"/>
    <url>/2020/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
