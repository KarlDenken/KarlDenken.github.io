<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hash 文件在macOS上的验证</title>
    <link href="/2020/05/30/Hash%20%E6%96%87%E4%BB%B6/"/>
    <url>/2020/05/30/Hash%20%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash-文件"><a href="#Hash-文件" class="headerlink" title="Hash 文件"></a>Hash 文件</h1><p>当我们从网络上下载得到一个文件，尤其是一个大文件时，，你会不会常常发现这一个一个问题：<strong>文件打不开</strong>！你会不会疑惑，明明从网上下载的文件好好的，怎么会出现文件错误，打不开呢？</p><h2 id="文件的完整性"><a href="#文件的完整性" class="headerlink" title="文件的完整性"></a>文件的完整性</h2><p>我们提到文件，尤其是大文件的下载的时候，我们常常会提到 <strong>P2P</strong> 或者是 <strong>磁力链</strong>。</p><ul><li><strong>P2P</strong>：P2P，也就是Peer-to-Peer的简称。以这种协议传输，每个电脑都会提供一份力量。文件被分成很多个小块，每台电脑都会提供一部分小块的上传和下载。</li></ul><p><img src="/assets/OIP.MoRYiSMe1GqCA9tLYZ3kYAHaFj.jpeg" srcset="/img/loading.gif" alt="P2P network"></p><ul><li><strong>磁力链</strong>：磁力链和P2P类似，但是P2P需要一个中心服务器来告诉各个电脑有谁有文件，而磁力链则会自动找最近的有文件的服务器。</li></ul><p>这两种方式都有一个问题，那就是文件被分割成小块在互联网上传输。如果其中一块出了问题，那整个文件都不可是使用了。所以我们需要一个方法来验证文件的完整度。</p><blockquote><p>目前主流下载软件是已经包含了验证文件完整度的流程的，不需要再次验证</p></blockquote><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>hash本质上就是一个函数，他的输入是一串二进制，输出为一串字符。我们就称呼这串字符为 <strong>文件哈希(file hash)</strong> 或者 <strong>验证符(checksums)</strong>。一个理想的hash函数应该满足独一性，即每个独特的文件只能产生一个文件哈希，以至于任何一个微小的改变都会改变文件哈希的值。</p><p>目前有很多的hash算法，包括<code>SHA-256</code>，<code>SHA3</code>，<code>SHA1</code>，<code>MD5</code>和<code>CRC32</code>。但是目前这些算法都不是绝对安全的（也就是说，有可能两个文件会产生同样的哈希），不过在日常生活中他们已经常用来验证文件的完整性。</p><p>这里不对各个Hash算法的原理进行深入研究，如果有需求可以看看<a href="https://zhuanlan.zhihu.com/p/37165658" target="_blank" rel="noopener">知乎专栏</a>进行了解。</p><h2 id="在mac上验证文件Hash"><a href="#在mac上验证文件Hash" class="headerlink" title="在mac上验证文件Hash"></a>在mac上验证文件Hash</h2><p>mac目前提供命令行指令来看文件的hash值：</p><ul><li><p>显示SHA256哈希：<code>shasum -a 256 [filenames]</code></p></li><li><p>显示SHA1哈希：<code>shasum -a 1 [filenames]</code></p></li><li><p>显示MD5哈希：<code>md5 -r [filenames]</code></p></li><li><p>显示CRC32哈希：<code>crc32 [filenames]</code></p></li></ul><p>有时候我们下载时会提供包含hash的验证文件。我们称呼这些文件为验证文件（checksums files）。一个验证文件（checksums file）一般包含多行hash-文件名对。你可以用一行指令轻松的验证所包含的所有文件。当有多个文件时，这个指令很管用。</p><blockquote><p>注意：验证文件必须与内部提到的文件在同一个文件夹</p></blockquote><ul><li><p>验证SHA256文件（通常文件名是 SHA256SUMS）：<code>shasum -a 256 -c [SHA256SUMS]</code></p></li><li><p>验证SHA1文件（通常文件名是 SHA1SUMS）：<code>shasum -a 1 -c [SHA1SUMS]</code></p></li></ul><p>mac不提供原生的MD5验证指令，但可以从<code>Homebrew</code>轻松下载：</p><p><code>brew install md5sha1sum</code></p><ul><li>验证MD5文件（通常文件名是 MD5SUMS）：<code>md5sum -c [MD5SUMS]</code></li></ul><h2 id="创建验证文件"><a href="#创建验证文件" class="headerlink" title="创建验证文件"></a>创建验证文件</h2><p>我们也可以生成自己的验证文件，可以用于日后的验证或者拷贝大型文件的完整性验证</p><p><code>shasum -a 256 [files] &gt; [SHA256SUMS]</code></p><blockquote><p>注意：SHA256对大型文件的处理速度比较慢，需要耐心等待</p></blockquote><p><img src="/assets/%E6%88%AA%E5%B1%8F2020-05-30%2015.16.00.png" srcset="/img/loading.gif" alt="截屏2020-05-30 15.16.00"></p><h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><p>在一些文件下载网站，如<a href="https://msdn.itellyou.cn" target="_blank" rel="noopener">MSDN</a>，里面的软件是会提供下载后验证SHA1的，我们可以下载之后验证文件的完整性。</p><p><img src="/assets/%E6%88%AA%E5%B1%8F2020-05-30%2015.21.56.png" srcset="/img/loading.gif" alt="截屏2020-05-30 15.21.56"></p><p>同时，有时候路边购买的U盘，也可能出现信息丢失的情况，我们也可以用这种方式验证文件完整性。</p><p>另外，对于大型的文档，我们在确定终稿的时候生成SHA文件，可以避免对文件的修改过于细微而无法确认文件的完备性。当然，最好还是用Git进行版本管理。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2020/05/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/05/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2020/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>背包问题泛指一下这一种问题：</p><blockquote><p>给定一组有价值和固定重量的物品，以及一个已知最大承重的背包，求在不超过背包最大承重量的前提下，能放进把背包里的物品的最大总价值。</p></blockquote><p>这是一种典型的使用 <strong>动态规划</strong> 解决的问题，我们可以具体分成三个问题：</p><ul><li>0-1 背包问题</li><li>完全背包问题</li><li>多重背包问题</li></ul><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0 - 1背包"></a>0 - 1背包</h2><blockquote><p>0 - 1 背包指每一种物品只有一件，可以选择放或者不放。假设有<code>n</code>件物品，背包承重为<code>C</code></p></blockquote><p>对于这种问题，我们用一个二维数组 <code>f[i][c]</code>，其中<code>i</code>表示放入背包的是前i件物品，<code>c</code>表示背包的承重，<code>f[i][c]</code>表示当前状态放进背包里的物品最大价值，那么最终结果就是<code>f[n][C]</code></p><p>动态规划有三个基本要素：<strong>最优子结构</strong>，<strong>边界条件</strong> 和 <strong>状态转移方程</strong>：</p><ul><li><strong>状态转移方程</strong>：对于第 <code>i</code>个物体，有两种可能，拿 或者 不拿。拿的话，则<code>f[i][c] = f[i-1][c - w[i]] + v[i]</code>，即在前<code>i-1</code>个物体，花销为<code>c-w[i]</code>的情况下，拿了第<code>i</code>个物体，同时花销多花了<code>w[i]</code>，收益增加了<code>v[i]</code>。不拿的话，则<code>f[i][c] = f[i-1][c]</code>，即在前<code>i-1</code>个物体，花销为<code>c</code>的情况下，不花<code>w[i]</code>，同时也没有收益。所以我们的状态转移方程为：</li></ul><pre><code class="python">f[i][c] = f[i-1][c-w[i]] + v[i] if add ith itemf[i][c] = f[i-1][c] if not add ith item</code></pre><ul><li><strong>最优子结构</strong>：我们的目的是为了获得最大的价值，所以最优子结构为：</li></ul><pre><code class="python">f[i][c] = max(f[i-1][c], f[i-1][c-w[i]] + v[i])</code></pre><ul><li><strong>边界条件</strong>：最开始我们的背包什么都没有，所以<code>f[0][0] = 0</code>，没有花销，同时也没有收益。当背包放满了，放不下了，我们也没法更新，所以 <code>f[i][c] = f[i-1][c] if c &lt; w[i]</code>，最后返回<code>f[n][C]</code></li></ul><p>有了上面的几个条件，我么就可以开始写代码了：</p><pre><code class="python">def knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  # w is the weight, v is the value, n is the number of item and m is the total cost affordable  f = [[0] * n for _ in range(C + 1)] # generate array  for j in range(1, C+1):    if j &gt;= w[0]:      f[0][j] = v[0] # when c &gt; w[0], we can at least put item 0 and get value v[0]      else:      f[0][j] = 0  for i in range(1, n):    for j in range(1, C+1):      if j &lt; w[i]:        f[i][j] = f[i-1][j]      else:        f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[[i]])  return f[n-1][C]</code></pre><p>我们用这样一个例子：总共有5个商品：a,b,c,d,e，重量为：2, 2, 6, 5, 4，价值为：6, 3, 5, 4, 6。背包可承载重量为10，我们可以得到下面的表格：</p><table><thead><tr><th></th><th>W</th><th>V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th align="center">备注</th></tr></thead><tbody><tr><td>a</td><td>2</td><td>6</td><td>0</td><td>0</td><td><strong>6</strong></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td align="center">consider item a</td></tr><tr><td>b</td><td>2</td><td>3</td><td>0</td><td>0</td><td>6</td><td>6</td><td><strong>9</strong></td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td><td align="center">consider item b</td></tr><tr><td>c</td><td>6</td><td>5</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>9</td><td>9</td><td><strong>11</strong></td><td>11</td><td>14</td><td align="center">consider item c</td></tr><tr><td>d</td><td>5</td><td>4</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>9</td><td>10</td><td>11</td><td>13</td><td>14</td><td align="center">consider item d</td></tr><tr><td>e</td><td>4</td><td>6</td><td>0</td><td>0</td><td>6</td><td>6</td><td>9</td><td>9</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td align="center">consider item e</td></tr></tbody></table><p>所以最后返回 <strong>15</strong>，也就是把a,b,e放到包里，总共重量8，总价值15</p><p>我们来计算时间复杂度和空间复杂度。两个循环嵌套，所以时间复杂度为O(nC)，空间复杂度开了一个[n][C]的数组，所以也是O(nC), 我们可以接着优化。我们发现，每一行数组都只跟上一级数组有关，所以空间复杂度可以简化为O(2C),我们还可以进一步优化为O(C)，那就是 <strong>从后往前填数组</strong>，因为对于i次更新，只会追溯到i-1次更新数据中c以前的数据，这样就只用保留一行数组。实质上也就是用上一轮的数据来更新这一轮。</p><pre><code class="python">def knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    for j in range(C, w[i]-1, -1):      f[j] = max(f[j], f[j - w[i]] + v[i])  return f[C]</code></pre><p>如果题目要求我们输出最优解，而不只是答案，我们需要保存么一次变化的值，用来回溯最优解。</p><p>如果固定背包必须装满，那么除了<code>f[0]</code>初始化为0，其他<code>f[1~c]</code>都要初始化为<code>float(&#39;-inf&#39;)</code>，可以理解为没要物体时，除了把背包容量为0，那么什么都不装刚好装满，如果背包容量大于0，则除了<code>f[0]</code>外我们那种情况都装不满，所以初始化为负无穷。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><blockquote><p>完全背包问题就是每一个物体有无数件，假设有<code>n</code>件物品，背包承重为<code>C</code></p></blockquote><p>相比于0-1背包，我们每一件物体选取没有数量限制，那么我们可以取0,1,2, … 到最多<code>C//w[i]</code>，按照0-1把背包的分析，我们可以写出状态转移方程：</p><pre><code class="python">f[i][j] = max(f[i-1][j], f[i-1][j - k * w[i]] + k * v[i]), where 0 &lt;= k*w[i] &lt;= j</code></pre><p>时间复杂度变为了$O(nC* \Sigma C // w[i])$，我们也有进行优化。</p><p>会想一下0-1背包中，第一层是从0到n-1，第二层从右到左。<strong>从右都左</strong> 是为了保证第i件物体一点从i-1件物体的撞状态而来，也就是说，考虑第i件物体时，依据的是一个一定没有选中过i-1件物体的结论。如果将第二层循环改成 <strong>从左到右</strong> 就变成选第i件物体时依然从拿过第i件物体的结论中递推。状态转移方程为：</p><pre><code class="python">f[i][j] = max(f[i-1][j], f[i][j - w[i]] + v[i])</code></pre><p>所以代码为：</p><pre><code class="python">def complete_knapsack(v: List[int], w: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(1, n):    for j in range(w[i], C + 1):      f[j] = max(f[j], f[j - w[i]] + v[i])  return f[C]</code></pre><p>这个写法和0-1背包几乎完全一致，不过第二层循环变成了从左到右更新。</p><h2 id="多重（有界）背包问题"><a href="#多重（有界）背包问题" class="headerlink" title="多重（有界）背包问题"></a>多重（有界）背包问题</h2><blockquote><p>如果限定物品i最多只能拿<code>m[i]</code>个，则问题称为有界或多重背包问题</p></blockquote><p>与完全背包相似，我们可以写出状态转移方程：</p><pre><code class="python">f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i])  where 0&lt;=k&lt;=m[i]</code></pre><p>此时时间复杂度为$O(C \Sigma m[i])$，一种简化的方法是将问题转化为物体数量为$\Sigma m[i]$的0-1背包问题，比如a有2个，每个价值为5，我们可以看作a1，a2两个物体，每个物体的价值是5。但时间复杂度还是$O(C \Sigma m[i])$。</p><p>我们尝试用二进制的思想来优化，将有m[i]个的第i件物体分成k+1组，每组一个系数，分别为$1, 2, 2^2, …, 2^{k-1}, m[i] - 2^k + 1$，k为保证最后一项大于0的最大整数，原本有m[i]件的第i件物体，被分成了log(m[i])件，每一件物体的价值和费用都乘以原来的系数倍，这样时间复杂度变成了$O(C \Sigma \log m[i])$</p><p>这样分组是为了保证0～m[i]中的每一个数都可以用新分组的系数组合而成，且不会超过m[i]，证明引用<a href="https://zhuanlan.zhihu.com/p/85780471" target="_blank" rel="noopener">知乎专栏</a></p><blockquote><p>首先看系数中除了最后一项的所有项，每一项都是2的次方，也就是说如果用二进制表示用它们组合可以得到$0$ ~ $2^k - 1$中的所有数，这样我们还剩下$2^k$~$m[i]$中的数需要表示，证明完成了一半；现在把最后一个系数加进来，我们发现它加上之前系数可以表示的最大值$2^k - 1$后得到的正是$m[i]$，我们可以想象先将所有系数全部取走，得到的便是$m[i]$，然后根据选择丢弃不需要的系数，我们便可以得到$m[i] - 2^k + 1$ ~ $m[i]$中的所有值（从$1$ ~ $2^k - 1$ 依次丢)，那么现在就剩下$0$ ~ $m[i] - 2^k$ 这些值需要表示，而现在只需要证明  $2^k - 1$ 比 $m[i] - 2^k$ 要大就行了，因为前面证明已经得到了 $0$ ~ $2^k - 1$ 之间的数，这个证明很简单，直接相减，然后利用 $m[i] - 2^k + 1 &gt; 0$的性质就可以得证。</p></blockquote><p>我们来写代码，我们要先抽象出0-1背包和完全背包，然后进一步定义<code>MultilePack</code></p><pre><code class="python">def zeroOnePack(f, wi, vi, C):  for j in range(C, wi - 1, -1):    f[j] = max(f[j], f[j - wi] + vi)def completePack(f, wi, vi, C):  for j in range(wi, C + 1):    f[j] = max(f[i], f[j - wi] + vi)def multiplePack(f, wi, vi, mi, C):  if mi * wi &gt;= C:    # can take all, like complete pack    completePack(f, wi, vi, C)    return  # the rest is 0 - 1 pack  k = 1  while k &lt; mi:    zeroOnePack(f, wi * k, vi * k, C)    mi -= k    k *= 2  # the rest  zeroOnePack(f, wi * mi, vi * mi, C)def multi_knapsack(v: List[int], w: List[int], m: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    multiplePack(f, w[i], v[i], m[i], C)  return f[C]</code></pre><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>如果物品中三种情况都有，那么我们可以分三种情况就行了</p><pre><code class="python">def hybrid_knapsack(v: List[int], w: List[int], m: List[int], n: int, C: int)  -&gt; int:  f = [0] * (C + 1)  for i in range(n):    if (m[i] == 1):      zeroOnePack(f, w[i], v[i], C)    elif m[i] == INT_MAX:      completePack(f, w[i], v[i], C)    else:      multiplePack(f, w[i], v[i], C)  return f[C]</code></pre><p>对于其他的，比如填满背包问题，找钱问题，我会在下一次的动态规划介绍中提出。</p>]]></content>
    
    
    <categories>
      
      <category>算法导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer（0）</title>
    <link href="/2020/04/18/%E5%89%91%E6%8C%87offer_0/"/>
    <url>/2020/04/18/%E5%89%91%E6%8C%87offer_0/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer（0）-知识储备"><a href="#剑指offer（0）-知识储备" class="headerlink" title="剑指offer（0）- 知识储备"></a>剑指offer（0）- 知识储备</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coronavirus and pets - How COVID-19 affects cats and dogs</title>
    <link href="/2020/04/06/English%20Expression%20Regarding%20COVID-19/"/>
    <url>/2020/04/06/English%20Expression%20Regarding%20COVID-19/</url>
    
    <content type="html"><![CDATA[<h1 id="Coronavirus-and-pets-How-COVID-19-affects-cats-and-dogs"><a href="#Coronavirus-and-pets-How-COVID-19-affects-cats-and-dogs" class="headerlink" title="Coronavirus and pets: How COVID-19 affects cats and dogs"></a>Coronavirus and pets: How COVID-19 affects cats and dogs</h1><p>Coronaviruses have lived and thrived in animals for thousands of years, but only a handful have been known to cause illness in humans. The coronavirus at the center of the current pandemic, SARS-CoV-2, is incredibly successful at spreading from human to human. As of early April — just four months after it was first detected — the virus had infected over 1 million people and spread to over 180 counties.</p><p>It turns out that SARS-CoV-2 can hijack animal cells, too. Scientists believe the disease originated in Chinese horseshoe bats before it jumped into an intermediary animal and, form there, found its way into humans. The virus is able to inject itself into cells by binding to a cell surface protein known as ACE2, which is present in many species of animal.</p><p>Some media reports have shown that the coronavirus can infect our companion animals — and more exotic species like tigers and lions — but cases are rare. It appears that transmission of the disease from human to animal is low, and there’s no reason to think you might catch the disease from a feline friend who has been wandering the neighborhood. The World Health Organization states there is “no evidence that a dog, cat or any pet can transmit COVID-19”.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发要求中的那些名词是什么</title>
    <link href="/2020/04/06/%E5%BC%80%E5%8F%91%E8%A6%81%E6%B1%82%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%90%8D%E8%AF%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/04/06/%E5%BC%80%E5%8F%91%E8%A6%81%E6%B1%82%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%90%8D%E8%AF%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="开发面试要求中的那些名词"><a href="#开发面试要求中的那些名词" class="headerlink" title="开发面试要求中的那些名词"></a>开发面试要求中的那些名词</h1><p>又到了一年的面试季，虽然收到新冠肺炎的影响，本次面试很多都是在线上进行，但是面试的难度仍然不减。笔者在投稿时也正在投简历和准备面试的重要节点。然而，现在算法的岗位处于白热化的竞争状态，相信很多读者和笔者一样有转投开发的岗位。可是很多开发岗位的名词尚属第一次听到，所以，这一次我们来了解一些那些可能出现在开发面试要求中的那些名词。</p><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>在2002年10月，Rod Johnson 在其撰写的 <em>Expert One-on-One J2EE</em> 的书中，提出了一个基于普通Java类和依赖注入的简单组件框架。在书中，他编写了超过 30,000 行的基础结构代码。包含许多可重用的 Java 接口和类。在书发布后不久，开发者 Juergen Hoeller 和 Yann Caroff 说服 Rod Johnson 创建一个基于基础结构代码的开源项目。随后，Rod，Juergen 和 Yann 于 2003 年 2 月左右开始合作开发该项目。Yann 为新框架创造了“Spring”的名字。Spring 框架也就此应运而生。</p><p>Spring 框架用一句话来说，就是 <strong>一个特殊的开发应用框架</strong>，这个框架有着以下几个标签：<code>轻量级</code>，<code>非侵入式</code>，<code>一站式</code>，<code>模块化</code>等特点。在Spring框架内，主要设计到的名词如下：</p><ul><li><p><strong>应用程序</strong>：能完成我们所需要功能的成品，比如购物网站，OA系统，ERP系统等。</p></li><li><p><strong>框架</strong>：是能完成一定功能的半成品。如果我们要来构造一个购物网站，我们可以通过框架进行开发，框架可以提供数据的写入，读取等功能，而我们可以设计一些额外的功能来完成商品的入库、出库等。这些框架提供了基础功能，可以很好的简化开发的流程。</p></li><li><p><strong>非侵入式设计</strong>：在设计中，无需继承框架提供的类，这样的设计，就是非侵入式设计。如果继承了这些框架类，就是侵入式设计。侵入式设计，如果以后想更换框架，之前写的代码就必须重写，如果是非侵入式设计，之前写过的代码可以接着使用。</p></li><li><p><strong>轻量级/重量级</strong>：轻量级是相较于重量级而言的。轻量级一般是非侵入式的，所依赖的东西非常好，占用的资源也非常少，部署简单，容易使用。重量级反之。</p></li><li><p><strong>POJO（Plain Old Java Object）</strong>：简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p></li><li><p><strong>容器</strong>：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p></li><li><p><strong>IOC（Inversion of Control）</strong>：控制反转，又叫做依赖注入，就是由容器控制程序之间的关系，而非传统设计中，由代码直接控制。</p></li><li><p><strong>Bean</strong>：Spring IoC 容器管理对象。</p></li><li><p><strong>AOP</strong>： AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p></li></ul><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache，也就是 <strong>缓存</strong>，就是将程序或者系统经常要调用的对象存在内存中，使用的时候可以快速调用，不必再去创建新的重复的实例，从而减少系统开销，提高系统效率。</p><p>缓存主要可以分成两大类：</p><ul><li><p><strong>文件缓存</strong>：把数据存储在磁盘上。</p></li><li><p><strong>内存缓存</strong>：实现一个类中静态Map，对这个Map进行常规的增删查。</p></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC框架，全称Remote Procedure Call Protocal，也就是远程过程调用协议。也就是两台服务器A，B，一个应用部署在服务器A上，想调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>]]></content>
    
    
    <categories>
      
      <category>名词解释</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
      <tag>名词解释</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在远程使用Jupyter Notebook</title>
    <link href="/2020/04/04/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BD%BF%E7%94%A8jupternoteboook/"/>
    <url>/2020/04/04/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BD%BF%E7%94%A8jupternoteboook/</url>
    
    <content type="html"><![CDATA[<h1 id="如何在远程使用Jupter-Notebook"><a href="#如何在远程使用Jupter-Notebook" class="headerlink" title="如何在远程使用Jupter Notebook"></a>如何在远程使用Jupter Notebook</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于很多同学而言，做研究，尤其是做人工智能的研究，都需要一台很强大的电脑。但是现在可以跑起来的电脑往往耗资巨大。很多学校都是使用一台强大的服务器，然后给学生们提供一个账号，利用这个账号登陆进行处理。但是这就出现了一个问题。很多同学已经习惯了使用Jupyter Notebook来进行可视化处理，对于远程的Linux服务器，如何可以使用Jupter Notebook呢？这篇文章就简要的告诉你如何处理这样的问题。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="登陆服务器"><a href="#登陆服务器" class="headerlink" title="登陆服务器"></a>登陆服务器</h3><p>首先需要 <strong>登陆你的远程Linux服务器</strong></p><pre><code class="shell">ssh &lt;your_ip_address&gt; -p &lt;your_port&gt;</code></pre><p>并在内部建立一个<code>jup</code>文件夹，用来存放notebook文件</p><h3 id="安装Jupyter-Notebook"><a href="#安装Jupyter-Notebook" class="headerlink" title="安装Jupyter Notebook"></a>安装Jupyter Notebook</h3><p>如果是使用的anaconda或者是miniconda，jupyter notebook已经安装好了。如果没有，需要在服务器端安装jupyter notebook</p><pre><code class="shell">conda install jupyter Notebook</code></pre><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><p>安装好了Jupyter Notebook，就需要来生成配置文件。如果是第一次设置配置文件，需要先生成配置文件</p><pre><code class="shell">jupyter notebook --generate-config</code></pre><p>生成文件之后，需要设置密码。如果密码是123456，则应该操作为</p><pre><code class="shell">&gt;&gt;&gt; from notebook.auth import passwd&gt;&gt;&gt; passwd(&#39;123456&#39;)&#39;sha1:xxxxxxxxxxxxxxxxxxxxxxxx&#39;</code></pre><p>会返回一个sha1密码，然后用vim打开刚刚的配置文件（一般会在根目录/.jupyter/jupyter_notebook_config.py），在开头插入下列一些代码</p><pre><code class="python">c.NotebookApp.ip=&#39;0.0.0.0&#39; # 广播给所有人c.NotebookApp.password = u&#39;&lt;密码&gt;&#39; # &lt;密码&gt;就是之前的sha1:xxxxxxxxxxxxc.NotebookApp.open_browser = False # 不打开浏览器c.NotebookApp.port = 8050 # 使用8050作为跳转的接口</code></pre><h3 id="设置后台运行"><a href="#设置后台运行" class="headerlink" title="设置后台运行"></a>设置后台运行</h3><p>成功设置之后，我们更需要Jupyter Notebook在后台运行。这样我们无论什么时候运行，只需要打开网页，我们就可以使用Jupyter Notebook了。这样更加方便。我们需要的指令就是<code>nohup</code></p><pre><code class="shell">cd &lt;your_directory&gt;nohup jupyter notebook --no-browser --port 8050 --ip=&lt;your ip&gt; 2&gt;&amp;1 &amp;</code></pre><p>其中<code>nohup</code>的目的就是不挂断的运行程序。并且在最后我们使用<code>&amp;</code>来保证在后台运行。我们开始jupyter notebook，不用浏览器，端口好设置为8050，ip地址设置为地址，<code>2&gt;&amp;1</code>中，&amp;1表示文件描述符，也就是标准输出stdout，2则表示标准错误，也就是stderr。整个的意思就是将标准错误重定向到标准输出。由于nohup会自动生成一个nohup log记录活动。这样的指令可以使所有的错误和标准指令都保存在nohup内部</p><h3 id="使用Jupyter-Notebook"><a href="#使用Jupyter-Notebook" class="headerlink" title="使用Jupyter Notebook"></a>使用Jupyter Notebook</h3><p>现在，打开任意浏览器，输入地址<code>https://&lt;your ip&gt;:8050/</code>，然后开始愉快的使用jupyter notebook吧</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>远程</tag>
      
      <tag>Jupyter Notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020</title>
    <link href="/2020/04/02/2020/"/>
    <url>/2020/04/02/2020/</url>
    
    <content type="html"><![CDATA[<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><p>回首2019，有那么多想干的事情没有干。原先想着到了2020年了，可以再加一把劲把事情都干完。可是突如其来的疫情，却彻底打乱了我的节奏。写下这段文字的时候，2020年转眼间已经过去了1/4，可是我却度过了人生有史以来最舒服的几个月。没有考虑任何东西，没有学习到任何东西。回望我的同学们，都利用这段时间进行了大范围的联系，可是我却白白浪费了。</p><p>好在意识到这个问题还不算晚，现在开始我也要好好学习，天天向上了。</p>]]></content>
    
    
    <categories>
      
      <category>自我</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我反省</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/02/hello-world/"/>
    <url>/2020/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
